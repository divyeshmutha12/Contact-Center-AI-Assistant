import { create } from "zustand";
import {
  WebSocketMessageHandler,
  FilteredMessage,
  StoredMessages,
  ChartConfig,
  ReportPath,
} from "./websocket-message-handler";
import { ThinkingStep, Message, Conversation, ResponseVersion } from "./types";
import { useAuthStore, setResetChatStore, setConnectWebSocket } from "./auth-store";
import {
  handleWebSocketMessage,
  createAssistantMessage,
  createErrorMessage,
  createResponseVersion,
  WebSocketHandlerCallbacks,
} from "./chat-store-helpers";

const WS_BASE_URL = process.env.NEXT_PUBLIC_WS_URL;

// ============================================
// Note: ws_id is now generated by the backend
// and sent to the frontend on connection.
// This simplifies the system: one WebSocket = one conversation thread.
// ============================================

// ============================================
// Chat Store Interface
// ============================================

interface ChatState {
  // Connection state
  isConnected: boolean;
  isLoading: boolean;
  isStreaming: boolean;
  error: string | null;

  // WebSocket ID from server (used for both session tracking and conversation memory)
  wsId: string | null;

  // Streaming content (final response to display)
  streamingContent: string;
  fullResponseContent: string;

  // Chart data from final response
  currentChartData: ChartConfig | null;

  // Report path for Excel download (e.g., "sessions/ws_id/outputs/report.xlsx")
  currentReportPath: ReportPath | null;

  // Thinking/reasoning messages (type: "message", role: "ai")
  thinkingSteps: ThinkingStep[];

  // Filtered messages from WebSocket
  filteredMessages: StoredMessages | null;
  currentQueryMessages: FilteredMessage[];

  // Conversations
  conversations: Conversation[];
  currentConversation: Conversation | null;

  // WebSocket instance and message handler
  ws: WebSocket | null;
  messageHandler: WebSocketMessageHandler | null;
  streamingIntervalId: NodeJS.Timeout | null;

  // Retry state - tracks which message is being retried
  retryingMessageId: string | null;
  retryingUserQuery: string | null;

  // Actions
  connect: () => void;
  reconnect: () => void;
  disconnect: () => void;
  sendQuery: (query: string) => void;
  retryQuery: (userMessageId: string, assistantMessageId: string, query: string) => void;
  setMessageVersion: (messageId: string, versionIndex: number) => void;
  setCurrentConversation: (conversation: Conversation | null) => void;
  addConversation: (conversation: Conversation) => void;
  updateConversation: (conversation: Conversation) => void;
  deleteConversation: (id: string) => void;
  clearStreamingContent: () => void;
  getFilteredMessages: () => StoredMessages | null;
  startFakeStreaming: (fullText: string, chartData?: ChartConfig, reportPath?: ReportPath) => void;
  stopFakeStreaming: () => void;
  addThinkingStep: (step: ThinkingStep) => void;
  clearThinkingSteps: () => void;
  clearChartData: () => void;
  clearReportPath: () => void;
  reset: () => void;
}

// ============================================
// Helper: Create WebSocket Handler Callbacks
// ============================================

function createHandlerCallbacks(
  get: () => ChatState,
  set: (partial: Partial<ChatState> | ((state: ChatState) => Partial<ChatState>)) => void
): WebSocketHandlerCallbacks {
  return {
    setSessionId: (wsId: string) => set({ wsId }),

    setFilteredMessages: () => {
      // Handled inline in handleWebSocketMessage
    },

    addThinkingStep: (step: ThinkingStep) => get().addThinkingStep(step),

    startFakeStreaming: (content: string, chartData?: ChartConfig, reportPath?: ReportPath) => {
      get().startFakeStreaming(content, chartData, reportPath);
    },

    getFullResponseContent: () => get().fullResponseContent,
    getCurrentConversation: () => get().currentConversation,
    isStillStreaming: () => get().isStreaming,
    getRetryingMessageId: () => get().retryingMessageId,
    getCurrentChartData: () => get().currentChartData,
    getCurrentReportPath: () => get().currentReportPath,
    getThinkingSteps: () => get().thinkingSteps,

    updateConversationWithRetry: (
      conv: Conversation,
      retryingMessageId: string,
      fullResponseContent: string,
      currentChartData: ChartConfig | null,
      currentReportPath: ReportPath | null,
      thinkingSteps: ThinkingStep[]
    ) => {
      const newVersion = createResponseVersion(fullResponseContent, currentChartData, currentReportPath, thinkingSteps);

      const updatedMessages = conv.messages.map((msg) => {
        if (msg.id === retryingMessageId) {
          const existingVersions = msg.responseVersions || [{
            id: `version-original-${msg.id}`,
            content: msg.content,
            timestamp: msg.timestamp,
          }];

          const newVersions = [...existingVersions, newVersion];

          return {
            ...msg,
            content: fullResponseContent,
            responseVersions: newVersions,
            currentVersionIndex: newVersions.length - 1,
          };
        }
        return msg;
      });

      const updatedConversation = { ...conv, messages: updatedMessages };

      set((state) => ({
        currentConversation: updatedConversation,
        conversations: state.conversations.map((c) =>
          c.id === updatedConversation.id ? updatedConversation : c
        ),
        streamingContent: "",
        fullResponseContent: "",
        isLoading: false,
        retryingMessageId: null,
        retryingUserQuery: null,
      }));
    },

    updateConversationWithNewMessage: (
      conv: Conversation,
      fullResponseContent: string,
      currentChartData: ChartConfig | null,
      currentReportPath: ReportPath | null,
      thinkingSteps: ThinkingStep[]
    ) => {
      const assistantMessage = createAssistantMessage(
        fullResponseContent,
        currentChartData,
        currentReportPath,
        thinkingSteps
      );

      const updatedConversation = {
        ...conv,
        messages: [...conv.messages, assistantMessage],
      };

      set((state) => ({
        currentConversation: updatedConversation,
        conversations: state.conversations.map((c) =>
          c.id === updatedConversation.id ? updatedConversation : c
        ),
        streamingContent: "",
        fullResponseContent: "",
        isLoading: false,
      }));
    },

    setLoadingComplete: () => {
      set({
        isLoading: false,
        streamingContent: "",
        fullResponseContent: "",
        retryingMessageId: null,
        retryingUserQuery: null,
      });
    },

    setError: (errorMsg: string, conv?: Conversation | null) => {
      if (conv) {
        const errorMessage = createErrorMessage(errorMsg);
        const updatedConv = {
          ...conv,
          messages: [...conv.messages, errorMessage],
        };

        set((state) => ({
          currentConversation: updatedConv,
          conversations: state.conversations.map((c) =>
            c.id === updatedConv.id ? updatedConv : c
          ),
          error: errorMsg,
          isLoading: false,
          streamingContent: "",
        }));
      } else {
        set({ error: errorMsg, isLoading: false, streamingContent: "" });
      }
    },
  };
}

// ============================================
// Helper: Setup WebSocket Connection
// ============================================

function setupWebSocket(
  url: string,
  get: () => ChatState,
  set: (partial: Partial<ChatState> | ((state: ChatState) => Partial<ChatState>)) => void,
  existingHandler: WebSocketMessageHandler | null
): void {
  const newWs = new WebSocket(url);
  const messageHandler = existingHandler || new WebSocketMessageHandler();
  const callbacks = createHandlerCallbacks(get, set);

  newWs.onopen = () => {
    console.log("[WS] Connected");
    set({ isConnected: true, error: null });
  };

  newWs.onmessage = (event) => {
    console.log("[WS] Raw message:", event.data);

    const filtered = messageHandler.handleMessage(event.data);
    if (!filtered) return;

    console.log("[WS] Filtered message:", filtered.type, filtered.role || "");

    const { currentQueryMessages } = get();
    handleWebSocketMessage(
      filtered,
      messageHandler,
      callbacks,
      currentQueryMessages,
      (updates) => set(updates as Partial<ChatState>)
    );
  };

  newWs.onerror = (error) => {
    console.error("[WS] Error:", error);
    set({ error: "Connection error", isLoading: false });
  };

  newWs.onclose = (event) => {
    console.log("[WS] Closed, code:", event.code);
    set({ isConnected: false, ws: null });
  };

  set({ ws: newWs, messageHandler });
}

// ============================================
// Chat Store Implementation
// ============================================

export const useChatStore = create<ChatState>((set, get) => ({
  // Initial state
  isConnected: false,
  isLoading: false,
  isStreaming: false,
  error: null,
  wsId: null,
  streamingContent: "",
  fullResponseContent: "",
  currentChartData: null,
  currentReportPath: null,
  thinkingSteps: [],
  filteredMessages: null,
  currentQueryMessages: [],
  conversations: [],
  currentConversation: null,
  ws: null,
  messageHandler: null,
  streamingIntervalId: null,
  retryingMessageId: null,
  retryingUserQuery: null,

  // Connect to WebSocket (initial connection without session_id)
  connect: () => {
    const { ws, isConnected, messageHandler: existingHandler } = get();
    const { tokens } = useAuthStore.getState();

    if (!tokens?.accessToken) {
      console.error("[WS] No access token available");
      set({ error: "Not authenticated" });
      return;
    }

    // Skip if already connected
    if (isConnected && ws && ws.readyState === WebSocket.OPEN) {
      console.log("[WS] Already connected, skipping");
      return;
    }

    if (ws) {
      ws.close();
    }

    const url = `${WS_BASE_URL}/ws/chat`;
    console.log("[WS] Connecting to:", url);

    setupWebSocket(url, get, set, existingHandler);
  },

  // Reconnect to WebSocket (server generates new ws_id)
  reconnect: () => {
    const { ws, messageHandler: existingHandler } = get();
    const { tokens } = useAuthStore.getState();

    if (!tokens?.accessToken) {
      console.error("[WS] No access token available");
      set({ error: "Not authenticated" });
      return;
    }

    if (ws) {
      ws.close();
    }

    const url = `${WS_BASE_URL}/ws/chat`;
    console.log("[WS] Reconnecting to:", url);

    setupWebSocket(url, get, set, existingHandler);
  },

  // Disconnect WebSocket
  disconnect: () => {
    const { ws } = get();
    if (ws) {
      ws.close();
      set({ ws: null, isConnected: false });
    }
  },

  // Send query via WebSocket
  sendQuery: (query: string) => {
    const { ws, isConnected, messageHandler, streamingIntervalId } = get();

    if (!isConnected || !ws) {
      set({ error: "Not connected to server", isLoading: false });
      return;
    }

    if (streamingIntervalId) {
      clearInterval(streamingIntervalId);
      set({ streamingIntervalId: null, isStreaming: false });
    }

    if (messageHandler) {
      messageHandler.resetMessages();
    }

    set({
      isLoading: true,
      error: null,
      streamingContent: "",
      fullResponseContent: "",
      currentChartData: null,
      currentReportPath: null,
      thinkingSteps: [],
      currentQueryMessages: [],
    });

    try {
      const { tokens } = useAuthStore.getState();
      const { wsId } = get();

      // Send query - server uses ws_id for both session and conversation memory
      const message = {
        type: "query",
        token: tokens?.accessToken,
        data: { message: query }
      };
      ws.send(JSON.stringify(message));
      console.log("[WS] Query sent:", query, "ws_id:", wsId);
    } catch (err) {
      console.error("[WS] Error sending query:", err);
      const errorMsg = err instanceof Error ? err.message : "Failed to send query";

      const { currentConversation } = get();
      if (currentConversation) {
        const errorMessage = createErrorMessage(errorMsg);
        const updatedConv = {
          ...currentConversation,
          messages: [...currentConversation.messages, errorMessage],
        };

        set((state) => ({
          currentConversation: updatedConv,
          conversations: state.conversations.map((c) =>
            c.id === updatedConv.id ? updatedConv : c
          ),
        }));
      }

      set({ error: errorMsg, isLoading: false });
    }
  },

  // Retry query - regenerate response for an existing message
  retryQuery: (_userMessageId: string, assistantMessageId: string, query: string) => {
    const { ws, isConnected, messageHandler, streamingIntervalId } = get();

    if (!isConnected || !ws) {
      set({ error: "Not connected to server", isLoading: false });
      return;
    }

    if (streamingIntervalId) {
      clearInterval(streamingIntervalId);
      set({ streamingIntervalId: null, isStreaming: false });
    }

    if (messageHandler) {
      messageHandler.resetMessages();
    }

    set({
      isLoading: true,
      error: null,
      streamingContent: "",
      fullResponseContent: "",
      currentChartData: null,
      currentReportPath: null,
      thinkingSteps: [],
      currentQueryMessages: [],
      retryingMessageId: assistantMessageId,
      retryingUserQuery: query,
    });

    try {
      const { tokens } = useAuthStore.getState();
      const { wsId } = get();

      // Send retry query - server uses ws_id for both session and conversation memory
      const message = {
        type: "query",
        token: tokens?.accessToken,
        data: { message: query }
      };
      ws.send(JSON.stringify(message));
      console.log("[WS] Retry query sent:", query, "ws_id:", wsId);
    } catch (err) {
      console.error("[WS] Error sending retry query:", err);
      const errorMsg = err instanceof Error ? err.message : "Failed to send query";
      set({
        error: errorMsg,
        isLoading: false,
        retryingMessageId: null,
        retryingUserQuery: null,
      });
    }
  },

  // Set which version of a message to display
  setMessageVersion: (messageId: string, versionIndex: number) => {
    const { currentConversation } = get();
    if (!currentConversation) return;

    let newChartData: ChartConfig | null = null;
    let newThinkingSteps: ThinkingStep[] = [];

    const updatedMessages = currentConversation.messages.map((msg) => {
      if (msg.id === messageId && msg.responseVersions) {
        const version = msg.responseVersions[versionIndex];
        if (version) {
          newChartData = version.chartData || null;
          newThinkingSteps = version.thinkingSteps || [];
          return {
            ...msg,
            content: version.content,
            currentVersionIndex: versionIndex,
          };
        }
      }
      return msg;
    });

    const updatedConversation = {
      ...currentConversation,
      messages: updatedMessages,
    };

    set((state) => ({
      currentConversation: updatedConversation,
      conversations: state.conversations.map((c) =>
        c.id === updatedConversation.id ? updatedConversation : c
      ),
      currentChartData: newChartData,
      thinkingSteps: newThinkingSteps,
    }));
  },

  // Conversation actions
  setCurrentConversation: (conversation) => set({ currentConversation: conversation }),

  addConversation: (conversation) =>
    set((state) => ({
      conversations: [conversation, ...state.conversations],
    })),

  updateConversation: (conversation) =>
    set((state) => ({
      conversations: state.conversations.map((c) =>
        c.id === conversation.id ? conversation : c
      ),
      currentConversation:
        state.currentConversation?.id === conversation.id
          ? conversation
          : state.currentConversation,
    })),

  deleteConversation: (id) =>
    set((state) => ({
      conversations: state.conversations.filter((c) => c.id !== id),
      currentConversation:
        state.currentConversation?.id === id ? null : state.currentConversation,
    })),

  clearStreamingContent: () => set({ streamingContent: "" }),

  getFilteredMessages: () => {
    const { filteredMessages } = get();
    return filteredMessages;
  },

  // Start fake word-by-word streaming (instant for long responses like reports)
  startFakeStreaming: (fullText: string, chartData?: ChartConfig, reportPath?: ReportPath) => {
    const { streamingIntervalId } = get();

    if (streamingIntervalId) {
      clearInterval(streamingIntervalId);
    }

    // For long responses (reports, tables), show instantly - no animation delay
    // This prevents 30+ second delays for large responses
    const INSTANT_DISPLAY_THRESHOLD = 500; // chars - responses longer than this show instantly

    if (fullText.length > INSTANT_DISPLAY_THRESHOLD) {
      // Show immediately for long responses (reports, tables, export data)
      console.log(`[Streaming] Long response (${fullText.length} chars) - showing instantly`);
      set({
        isStreaming: false,
        fullResponseContent: fullText,
        streamingContent: fullText,
        currentChartData: chartData || null,
        currentReportPath: reportPath || null,
        streamingIntervalId: null,
      });
      return;
    }

    // For short responses, do word-by-word streaming with faster animation
    const words = fullText.split(/(\s+)/);
    let wordIndex = 0;
    let displayedText = "";

    set({
      isStreaming: true,
      fullResponseContent: fullText,
      streamingContent: "",
      currentChartData: chartData || null,
      currentReportPath: reportPath || null,
    });

    // Faster streaming: process 3 words per tick at 15ms intervals
    const intervalId = setInterval(() => {
      if (wordIndex < words.length) {
        // Process multiple words per tick for faster display
        for (let i = 0; i < 3 && wordIndex < words.length; i++) {
          displayedText += words[wordIndex];
          wordIndex++;
        }
        set({ streamingContent: displayedText });
      } else {
        clearInterval(intervalId);
        set({
          isStreaming: false,
          streamingIntervalId: null,
          streamingContent: fullText,
        });
      }
    }, 15);

    set({ streamingIntervalId: intervalId });
  },

  // Stop fake streaming and show full content
  stopFakeStreaming: () => {
    const { streamingIntervalId, fullResponseContent } = get();

    if (streamingIntervalId) {
      clearInterval(streamingIntervalId);
    }

    set({
      isStreaming: false,
      streamingIntervalId: null,
      streamingContent: fullResponseContent,
    });
  },

  // Add a thinking step (AI reasoning message)
  addThinkingStep: (step: ThinkingStep) => {
    set((state) => ({
      thinkingSteps: [...state.thinkingSteps, step],
    }));
  },

  // Clear all thinking steps
  clearThinkingSteps: () => {
    set({ thinkingSteps: [] });
  },

  // Clear chart data
  clearChartData: () => {
    set({ currentChartData: null });
  },

  // Clear report path
  clearReportPath: () => {
    set({ currentReportPath: null });
  },

  reset: () => {
    const { ws, messageHandler, streamingIntervalId } = get();

    if (streamingIntervalId) {
      clearInterval(streamingIntervalId);
    }

    if (ws) {
      ws.close();
    }
    if (messageHandler) {
      messageHandler.resetMessages();
    }

    set({
      isConnected: false,
      isLoading: false,
      isStreaming: false,
      error: null,
      wsId: null,
      streamingContent: "",
      fullResponseContent: "",
      currentChartData: null,
      currentReportPath: null,
      thinkingSteps: [],
      filteredMessages: null,
      currentQueryMessages: [],
      conversations: [],
      currentConversation: null,
      ws: null,
      messageHandler: null,
      streamingIntervalId: null,
      retryingMessageId: null,
      retryingUserQuery: null,
    });
  },
}));

// Register the reset function with auth store to handle logout
setResetChatStore(() => useChatStore.getState().reset());

// Register the connect function with auth store for auto-connect on login
setConnectWebSocket(() => useChatStore.getState().connect());
